/*
Copyright 2011. All rights reserved.
Institute of Measurement and Control Systems
Karlsruhe Institute of Technology, Germany

Authors: Andreas Geiger

libicp is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or any later version.

libicp is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
libicp; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA 02110-1301, USA 
*/

#ifndef ICP_POINT_TO_POINT_H
#define ICP_POINT_TO_POINT_H

#include "icp.h"

class IcpPointToPoint : public Icp {

public:

  IcpPointToPoint (double *M,const int32_t M_num,const int32_t dim) : Icp(M,M_num,dim) {}
  virtual ~IcpPointToPoint () {}

  // ICP의 한 단계를 진행하기 위한 함수
  double fitStep (double *T,const int32_t T_num,Matrix &R,Matrix &t,const std::vector<int32_t> &active);

  // ICP 결과의 error를 측정하기 위한 함수 (only for 3D points)
  double getICPError(double* T, const int32_t T_num, Matrix& R, Matrix& t, const double indist);

  // target에 대해 일정거리 이하에 있는 source 점들을 list로 반환
  std::vector<int32_t> getInliers (double *T,const int32_t T_num,const Matrix &R,const Matrix &t,const double indist);

  // target에 대해 일정범위 안에 있는 source 들을 list로 반환 (3차원에 대해서만 동작함)
  std::vector<int32_t> getRanges(double* T, const int32_t T_num, const Matrix& R, const Matrix& t, const double min, const double max);

  // Source의 각 점에서 가장 가까운 Target 점의 index를 return한다
  std::vector<int32_t> getNearestIdxs(double* T, const int32_t T_num, const Matrix& R, const Matrix& t);
};

#endif // ICP_POINT_TO_POINT_H
